@page "/"
@page "/{Date}"
@using System.ComponentModel;
@using System.Runtime.CompilerServices;
@using Volo.Abp.AspNetCore.Components.Notifications;
@using We.Turf.Entities;
@using We.Utilities;
@inject IPmuServiceAppService pmuService;
@inject IUiNotificationService notification;
@implements INotifyPropertyChanged
<Row>

    <Column Class="col-sm-8 col-md-6 col-lg-5  mx-auto ">

        <Div Class="programme-tab container">
            <Row>
                <Column ColumnSize="ColumnSize.IsFull">
                    <CascadingValue Name="SelectMode" Value="_mode">
                        <CascadingValue Name="Date" Value="CurrentDate" TValue="DateOnly?">
                            <ProgrammeHeader DateChanged="SetDate" OnSelectMode="ShowCourseOrReunion"></ProgrammeHeader>
                        </CascadingValue>
                    </CascadingValue>
                </Column>

            </Row>
            <Row>
                <Column ColumnSize="ColumnSize.IsFull">
                    @if (CurrentDate == Today)
                    {
                        <CascadingValue Name="Predicteds" Value="Predicteds">
                            <ProgrammeContent />
                        </CascadingValue>

                    }
                    else if (CurrentDate < Today && ShowProgrammeCourse)
                    {
                        <CascadingValue Name="ProgrammeCourses" Value="ProgrammeCourses">
                            <CascadingValue Name="Predicteds" Value="Predicteds">
                                <CascadingValue Name="ResultatsOfPredicteds" Value="ResultatsOfPredicteds">
                                    <CascadingValue Name="Resultats" Value="ResultatOfPredictedStatistical">
                                        <CascadingValue Name="PredictionsOnly" Value="PredictionsOnly">
                                            <ProgrammeCourseContent SommeDesMises="SommeDesMises" />
                                        </CascadingValue>
                                    </CascadingValue>
                                </CascadingValue>
                            </CascadingValue>
                        </CascadingValue>
                    }
                    else if (CurrentDate < Today && ShowProgrammeReunion)
                    {

                        <CascadingValue Name="ProgrammeReunions" Value="ProgrammeReunions">
                            <ProgrammeReunionContent />
                        </CascadingValue>
                    }


                </Column>

            </Row>
        </Div>
    </Column>
    <Column Class="col-lg-7 d-none d-lg-block">
        <Div Class="main-tab container">
            <LineChart @ref="lineChart" TItem="double" />
        </Div>
    </Column>
</Row>

@code {
    private DateOnly? _date;
    private DateOnly? Today;
    private IDisposable? _whenDateChangedToToday;
    private IDisposable? _whenDateChangeBeforeToday;
    private SelectMode? _mode;
    private bool ShowProgrammeCourse => _mode == SelectMode.Course;
    private bool ShowProgrammeReunion => _mode == SelectMode.Reunion;
    private List<PredictedDto> Predicteds { get; set; } = new();
    private List<ProgrammeCourseDto> ProgrammeCourses { get; set; } = new();
    private List<ProgrammeReunionDto> ProgrammeReunions { get; set; } = new();
    private List<ResultatDto> Resultats { get; set; } = new();
    private List<ResultatOfPredictedDto> ResultatOfPredicteds { get; set; } = new();
    private List<ResultatOfPredictedStatisticalDto> ResultatOfPredictedStatistical { get; set; } = new();
    private List<PredictedOnlyDto> PredictionsOnly { get; set; } = new();
    private Dictionary<(int, int), IEnumerable<ResultatPlace>> ResultatsOfPredicteds = new();
    public event PropertyChangedEventHandler? PropertyChanged = null;
    public (int Mises, double Dividendes) SommeDesMises = (0, 0.0);
    public Index()
    {
    }
    protected override void OnInitialized()
    {
        _whenDateChangedToToday = this.WhenPropertyChanged()
       .Where(e => e.EventArgs.PropertyName == nameof(CurrentDate))
       .Select(e => _date)
       .Where(d => d == Today)
       .Subscribe(async date => await LoadPredictedAsync(date));

        _whenDateChangeBeforeToday = this.WhenPropertyChanged()
       .Where(e => e.EventArgs.PropertyName == nameof(CurrentDate))
       .Select(e => _date)
       .Where(d => d < Today)
       .Subscribe(async date =>
       {
           await LoadProgammeCourseAsync(date);
           await LoadProgammeReunionAsync(date);
           await LoadPredictedAsync(date);
           await LoadResultats(date);
           await LoadResultatOfPredicteds(date);
           await LoadPredictedOnly(date);

           await InternalInitializationAsync();

           await InvokeAsync(StateHasChanged);
       });
        ShowCourseOrReunion(SelectMode.Course);
        Today = DateOnly.FromDateTime(DateTime.Now);
        NotifyPropertyChanged("CurrentDate");

    }
    protected async Task InternalInitializationAsync()
    {
        foreach (var course in ProgrammeCourses.OrderBy(x=>x.Reunion).ThenBy(x=>x.Course))
        {
            ResultatsOfPredicteds[(course.Reunion, course.Course)] = GetResultats(course);
        }
        SommeDesMises = CalculSommeDesMises();
        Labels = ProgrammeCourses.OrderBy(x => x.Reunion).ThenBy(x => x.Course).Select(x => $"R{x.Reunion}C{x.Course}").ToArray();

        await HandleRedraw();
    }
    IEnumerable<PredictedDto> GetPredicted(ProgrammeCourseDto course) => Predicteds.Where(x => x.Reunion == course.Reunion && x.Course == course.Course).OrderBy(x => x.NumeroPmu);

    IEnumerable<ResultatPlace> GetResultats(ProgrammeCourseDto course)
    {
        var res = from resultat in GetPredicted(course)
                  group resultat by resultat.NumeroPmu into gp
                  select new ResultatPlace(gp.Key, gp.Count(), GetDividende(course, gp.Key));


        return res;
    }

    bool GetIsPlace(ProgrammeCourseDto course, int numeroPmu) => course.Arrivee.Take(3).Contains(numeroPmu);
    double GetDividende(ProgrammeCourseDto course, int numeroPmu)
    {

        var res = ResultatOfPredictedStatistical?.FirstOrDefault(x => x.Reunion == course.Reunion && x.Course == course.Course && x.NumeroPmu == numeroPmu && GetIsPlace(course, numeroPmu))?.Dividende ?? 0.0;
        /*if (course.Reunion == 2 && course.Course == 2)
            Debugger.Break();*/
        return res;
    }
#pragma warning disable BL0007
    [Parameter]
    public string Date
    {
        get => _date?.ToShortDateString() ?? string.Empty;
        set
        {
            var res = value.TryParseToDateOnly(out var __date);
            if (!res)
            {
                __date = DateOnlyExtensions.Now;
            }
            CurrentDate = __date;

        }
    }
#pragma warning restore BL0007
    internal DateOnly? CurrentDate
    {
        get => _date;
        set
        {
            _date = value;
            NotifyPropertyChanged();
        }
    }

    private void SetDate(DateOnly d)
    {
        CurrentDate = d;
    }
    private void ShowCourseOrReunion(SelectMode mode)
    {
        _mode = mode;
        // ShowProgrammeCourse = mode == SelectMode.Course;
        //ShowProgrammeReunion = !ShowProgrammeCourse;
        StateHasChanged();
    }

    private async Task LoadPredictedOnly(DateOnly? date)
    {
        var t = pmuService.BrowsePredictionOnly(new() { Date = date });
        var (res, response, errors) = await t;
        if (res)
        {
            PredictionsOnly = response.Predicteds;

        }
        else
        {
            await notification.Warn(errors.AsString());
        }
    }

    private async Task LoadResultatOfPredicteds(DateOnly? date)
    {
        var t = pmuService.BrowseResultatOfPredictedStatistical(new() { Date = date });
        var (res, response, errors) = await t;
        if (res)
        {
            ResultatOfPredictedStatistical = response.Resultats;

        }
        else
        {
            await notification.Warn(errors.AsString());
        }
    }
    private async Task LoadResultats(DateOnly? date)
    {
        var t = pmuService.BrowseResultat(new() { Date = date });
        var (res, response) = await t;
        if (res)
        {
            Resultats = response.Resultats;

        }
    }
    private async Task LoadPredictedAsync(DateOnly? date)
    {
        var t = pmuService.BrowsePrediction(new() { Date = date });
        var (res, response) = await t;
        if (res)
        {
            Predicteds = response.Predicteds;

        }
        //await InvokeAsync(StateHasChanged);
    }

    private async Task LoadProgammeCourseAsync(DateOnly? date)
    {
        if (date is null)
            return;
        var t = pmuService.BrowseProgrammeCourse(new() { Date = (DateOnly)date });
        var (res, response) = await t;
        if (res)
            ProgrammeCourses = response.Programmes;
        //await InvokeAsync(StateHasChanged);
    }

    private async Task LoadProgammeReunionAsync(DateOnly? date)
    {
        if (date is null)
            return;
        var t = pmuService.BrowseProgrammeReunion(new() { Date = (DateOnly)date });
        var (res, response) = await t;
        if (res)
            ProgrammeReunions = response.Reunions;
        //await InvokeAsync(StateHasChanged);
    }
    protected void NotifyPropertyChanged([CallerMemberName] string propertyName = "")
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }


    public (int, double) CalculSommeDesMises()
       => (PredictionsOnly.DistinctBy(x=>x.Hash).Count(), ResultatOfPredictedStatistical.DistinctBy(x=>x.Hash).Sum(x => x.Dividende));
    #region Chart
    LineChart<double> lineChart;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await HandleRedraw();
        }
    }

    async Task HandleRedraw()
    {
        await lineChart.Clear();

        await lineChart.AddLabelsDatasetsAndUpdate(Labels, GetLineChartDataset());
    }

    LineChartDataset<double> GetLineChartDataset()
    {
        return new LineChartDataset<double>
            {
                Label = "# of randoms",
                Data = GetChartData(),// RandomizeData(),
                BackgroundColor = backgroundColors,
                BorderColor = borderColors,
                Fill = true,
                PointRadius = 3,
                CubicInterpolationMode = "monotone",
            };
    }

    string[] Labels = Array.Empty<string>();
    List<string> backgroundColors = new List<string> { ChartColor.FromRgba(255, 99, 132, 0.2f), ChartColor.FromRgba(54, 162, 235, 0.2f), ChartColor.FromRgba(255, 206, 86, 0.2f), ChartColor.FromRgba(75, 192, 192, 0.2f), ChartColor.FromRgba(153, 102, 255, 0.2f), ChartColor.FromRgba(255, 159, 64, 0.2f) };
    List<string> borderColors = new List<string> { ChartColor.FromRgba(255, 99, 132, 1f), ChartColor.FromRgba(54, 162, 235, 1f), ChartColor.FromRgba(255, 206, 86, 1f), ChartColor.FromRgba(75, 192, 192, 1f), ChartColor.FromRgba(153, 102, 255, 1f), ChartColor.FromRgba(255, 159, 64, 1f) };

    List<double> RandomizeData()
    {
        var r = new Random(DateTime.Now.Millisecond);

        return new List<double> {
            r.Next( -50, 50 ) * r.NextDouble(),
            r.Next( -50, 50 ) * r.NextDouble(),
            r.Next( -50, 50 ) * r.NextDouble(),
            r.Next( -50, 50 ) * r.NextDouble(),
            r.Next( -50, 50 ) * r.NextDouble(),
            r.Next( -50, 50 ) * r.NextDouble() };
    }

    List<double> GetChartData()
    {
        if ( !ResultatOfPredictedStatistical?.Any() ?? false)
            return new();
        Dictionary<(int,int),double> res = new();
        double cumul = 0;
#pragma warning disable  CS8604
        var items = ResultatOfPredictedStatistical.DistinctBy(x => x.Hash).OrderBy(x => x.Reunion).ThenBy(x => x.Course);
#pragma warning restore CS8604
        foreach (var key in ResultatsOfPredicteds.Keys)
        {
            var v = ResultatsOfPredicteds[key];
           
            //if(res.TryGetValue((item.Reunion,item.Course),out var currentValue))
            cumul = cumul + v.Sum(x => x.DividendePlace) - v.Count();
            res[key] = cumul;
            
        }
        return res.Values.ToList();
    }
    #endregion
}
